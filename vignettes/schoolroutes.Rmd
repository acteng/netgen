---
title: "SchoolRoutes demo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SchoolRoutes demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include = FALSE}
install.packages("tmap", repos = c("https://r-tmap.r-universe.dev", "https://cloud.r-project.org"))
```

```{r setup}
library(netgen)
```


```{r}
library(sf)
library(tidyverse)
library(tmap)
# # Get the datasets, see: https://github.com/acteng/netgen/releases/tag/v0.1.0
# Automate data download if you have gh installed and authorised with:
# theme void:
theme_set(theme_void())
```

We'll start by saving the `zones` data in the `input` folder:

```{r}
origin_zones = netgen::zones_york
names(origin_zones)
names(origin_zones)[1] = "name"
dir.create("input", showWarnings = FALSE)
sf::write_sf(origin_zones, "input/zones.geojson", delete_dsn = TRUE)
```

Then we will use the `od2net` R package to generate the origins and destinations:

```{r}
#| eval: false
od2net::make_osm(zones_file = "input/zones.geojson")
od2net::make_origins()
# Optionally, get elevation data:
# netgen:::make_elevation()
destinations = netgen::destinations_york # Provided in the R package
names(destinations)[1] = "name"
destinations = destinations[1]
class(destinations$name) = "character"
sf::write_sf(destinations, "input/destinations.geojson", delete_dsn = TRUE)
```

Finally we'll save the OD dataset:

```{r}
# Save the OD dataset:
od_geo = sf::read_sf("https://github.com/acteng/netgen/releases/download/v0.1.0/res_output.geojson")
od = od_geo |>
  sf::st_drop_geometry() |>
  transmute(from = O, to = as.character(D), count = round(trips_modelled))
readr::write_csv(od, "input/od.csv", quote = "all")
```

The `od2net` package requires a configuration file to run. We will use the following configuration file:

```{r}
readLines("config_pct_govtarget.json") |> cat(sep = "\n")
```

```{r}
#| eval: false
system("od2net config_pct_govtarget.json --rng-seed 42")
```

If the previous lines of code run successfully and you have `od2net` installed, you should output in the console the following message:

```
Input: Test data for SchoolRoutes project.
- Origins: 19,258
- Destinations: 62
- Requests: 25,515
- Requests (succeeded): 25,364
- Requests (failed because same endpoints): 12
- Requests (failed because no path): 139
- Edges with a count: 37,388
- Total distance on not allowed roads: 2.4 km
- Total distance on LTS 1 roads: 12868.2 km
- Total distance on LTS 2 roads: 18057.4 km
- Total distance on LTS 3 roads: 25217.0 km
- Total distance on LTS 4 roads: 6634.4 km
```

After completing, the following files should be in the `output` folder:

```{r}
#| eval: false
list.files("output")
#> [1] "counts.csv"              "failed_requests.geojson"
#> [3] "output.geojson"          "rnet.pmtiles"
```


```{r}
#| eval: false
#| echo: false
file.copy("vignettes/output/output.geojson", "output_pct_govtarget.geojson")
system("gh release upload v0.1.0 output_pct_govtarget.geojson")
```

The most relevant of these is the 'output.geojson' file, which is also provided as a compressed `pmtiles` file.
You can visualise the results in the web app hosted at [od2net.org](https://od2net.org) by uploading the `output.pmtiles` file, resulting in an interactive map of the routes, as shown in the figure below.

```{r od2net, fig.cap = "Routes generated by the SchoolRoutes project."}
#| echo: false
knitr::include_graphics("od2net.png")
```

We can also visualise the data with the following code in R:


```{r}
#| echo: false
output_file = "https://github.com/acteng/netgen/releases/download/v0.1.0/output_pct_govtarget.geojson"
```

```{r}
#| eval: false
output_file = "output/output.geojson"
```


```{r}
rnet_govtarget = sf::read_sf(output_file)
nrow(rnet_govtarget)
names(rnet_govtarget)
plot(rnet_govtarget["count"], logz = TRUE)
```

The output above shows that the object has the following variables:

```
 [1] "backward_cost"     "count"             "destination_count"
 [4] "forward_cost"      "length"            "lts"              
 [7] "nearby_amenities"  "node1"             "node2"            
[10] "origin_count"      "osm_tags"          "way"              
[13] "geometry" 
```

Of these, `count`, `lts`, `osm_tags`, and `way` are the most relevant. Let's take a look at these for a sample of 3 rows:

```{r}
set.seed(42)
rnet_govtarget |>
  dplyr::slice_sample(n = 3) |>
  dplyr::select(count, lts, osm_tags, way)
```

As shown above, the `osm_tags` field has all the OSM tags in JSON format, which can be read-in with `jsonlite::fromJSON`:

```{r}
rnet_govtarget$osm_tags[1]
jsonlite::fromJSON(rnet_govtarget$osm_tags[1])
```

Let's create a slightly more sophisticated map with `tmap`, and let's make it interactive, by first filtering only the top segments:

```{r}
library(tmap)
rnet_govtarget_top = rnet_govtarget |>
  dplyr::transmute(count = as.integer(count), way) |>
  dplyr::slice_max(count, n = 5000) |>
  dplyr::arrange(count)
tmap_mode("view")
m = tm_shape(rnet_govtarget_top) +
  tm_lines(col = "count", col.scale = tm_scale(values = "viridis", breaks = c(0, 10, 20, 50, 200)), lwd = 9)
m
```

```{r}
#| eval: false
#| echo: false
#| label: reprex
remotes::install_github("r-tmap/tmap")
library(tmap)
output_file = "https://github.com/acteng/netgen/releases/download/v0.1.0/output_pct_govtarget.geojson"
rnet_govtarget = sf::read_sf(output_file)
rnet_govtarget_top = rnet_govtarget |>
  dplyr::transmute(count = as.integer(count), way) |>
  dplyr::slice_max(count, n = 5000) |>
  dplyr::arrange(count)
m = tm_shape(rnet_govtarget_top) +
  tm_lines(col = "count", col.scale = tm_scale(values = "viridis", breaks = c(0, 10, 20, 50, 200)), lwd = 9)
m
```

You can save and view the map as follows:

```{r}
#| eval: false
tmap_save(m, "output_pct_govtarget.html")
browseURL("output_pct_govtarget.html")
system("gh release upload v0.1.0 output_pct_govtarget.html")
```

# Sense checking the results

Do the results make sense?
We'll find out by comparing the total number of trips and distance travelled represented in the OD dataset with the output of the model:

```{r}
od_geo$length = sf::st_length(od_geo) |> as.numeric()
sum(od_geo$trips_modelled) # 26k
distance_euclidean_total = sum(od_geo$length * od_geo$trips_modelled)
distance_euclidean_total # 49,000 km
```

Let's do a sense check of the weighted average trip distance:

```{r}
weighted.mean(od_geo$length, od_geo$trips_modelled) # 1.9 km
```

Assuming a trip diversion factor of 1.3 and that 5% of the trips are made by cycling under the Government Target scenario for the short distances travelled to school, we can estimate the total number of trips and distance travelled:

```{r}
total_euclidean_cycled = distance_euclidean_total * 1.3 * 0.05
total_euclidean_cycled # just over 3,000 km
```

The equivalent for the route network output is:

```{r}
rnet_govtarget$length = sf::st_length(rnet_govtarget) |> as.numeric()
total_rnet = sum(rnet_govtarget$count * rnet_govtarget$length, na.rm = TRUE)
round(total_rnet / 1e3) # A bit over 4,000 km
```